-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
  fun evalStep(c, instruction) {
    fun readImpl([stack, state, w]) {
      case readWorld(w) of 
        [value, newWorld] -> [value:stack, state, newWorld]
      esac
    }

    fun writeImpl([head:tail, state, w]) {
      [tail, state, writeWorld(head, w)]
    }

    fun binopImpl([rhs:lhs:tail, state, w], op) {
      fun evalBinOp(op, lhs, rhs) {
        case op of 
          "+"  -> lhs + rhs
        | "-"  -> lhs - rhs
        | "*"  -> lhs * rhs
        | "/"  -> lhs / rhs
        | "%"  -> lhs % rhs
        | "==" -> lhs == rhs
        | "!=" -> lhs != rhs
        | "<"  -> lhs < rhs
        | "<=" -> lhs <= rhs
        | ">"  -> lhs > rhs
        | ">=" -> lhs >= rhs
        | "&&" -> lhs && rhs
        | "!!" -> lhs !! rhs
        esac
      }

      [evalBinOp(op, lhs, rhs):tail, state, w]
    }

    fun storeImpl([value:tail, state, w], name) {
      [tail, state <- [name, value], w]
    }

    fun pushImpl([stack, state, w], value) {
      [value:stack, state, w]
    }

    fun loadImpl(c@[stack, state, w], name) {
      pushImpl(c, state(name))
    }

    case instruction of 
      READ          -> readImpl(c)
    | WRITE         -> writeImpl(c)
    | BINOP (op)    -> binopImpl(c, op)
    | LD    (name)  -> loadImpl(c, name)
    | ST    (name)  -> storeImpl(c, name)
    | CONST (value) -> pushImpl(c, value)     
    esac
  }

  case insns of 
    {}                       -> c
  | instruction:instructions -> eval(evalStep(c, instruction), instructions)
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
  case expr of
    Var (name)                     -> { LD (name) }
  | Const (value)                  -> { CONST (value) }
  | Binop (op, lhs_expr, rhs_expr) -> compileExpr(lhs_expr) +++ compileExpr(rhs_expr) +++ { BINOP (op) }
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of 
    Assn (name, expr)         -> compileExpr(expr) +++ { ST (name) }
  | Seq (lhs_stmt, rhs_stmt)  -> compileSM(lhs_stmt) +++ compileSM(rhs_stmt)
  | Skip                      -> {}
  | Read (name)               -> { READ, ST (name) }
  | Write (expr)              -> compileExpr(expr) +++ { WRITE }
  esac  
}
